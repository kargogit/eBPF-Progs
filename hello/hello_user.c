// hello_user.c
#include <stdio.h>
#include <unistd.h>
#include <sys/resource.h>
#include <bpf/bpf.h>
#include "hello_kern.skel.h" // This will be generated by the build system

// Increase resource limits for eBPF
// eBPF programs can use a lot of memory-mapped regions
int libbpf_print_fn(enum libbpf_print_level level,
                    const char *format, va_list ap)
{
    // Suppress info/debug messages in production
    if (level > LIBBPF_WARN)
        return 0;
    return vfprintf(stderr, format, ap);
}

int main(int argc, char **argv)
{
    struct hello_kern *skel;
    int err;

    // Set up libbpf logging and errors
    libbpf_set_print(libbpf_print_fn);

    // Open, load, and attach the eBPF program
    // The skeleton is generated by bpftool and contains
    // all the boilerplate for loading and managing our program
    skel = hello_kern__open();
    if (!skel) {
        fprintf(stderr, "Failed to open BPF skeleton\\n");
        return 1;
    }

    // Load and verify the program
    // This is where the kernel verifier runs!
    err = hello_kern__load(skel);
    if (err) {
        fprintf(stderr, "Failed to load BPF program: %d\\n", err);
        return 1;
    }

    // Attach the program to the tracepoint
    err = hello_kern__attach(skel);
    if (err) {
        fprintf(stderr, "Failed to attach BPF program: %d\\n", err);
        return 1;
    }

    printf("eBPF Hello World loaded. Check /sys/kernel/debug/tracing/trace_pipe\\n");
    printf("Press Ctrl+C to exit.\\n");

    // Keep the program running
    // The eBPF program will fire in the background
    while (1) {
        sleep(1);
    }

    // Cleanup happens automatically when skel is freed
    return 0;
}
