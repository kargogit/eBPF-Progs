// socket_filter_user.c
//
// User-space program that loads the eBPF socket filter and attaches it to a raw packet socket.
//
// Overall flow:
// 1. Increase RLIMIT_MEMLOCK — eBPF maps and programs use memory-mapped regions.
// 2. Open and load the eBPF object using libbpf's skeleton (generated by bpftool).
// 3. Create a raw packet socket that captures all Ethernet protocols (ETH_P_ALL).
// 4. Attach the loaded eBPF program to the socket via setsockopt(SO_ATTACH_BPF).
// 5. Enter a receive loop to keep the socket alive and process packets.
//
// Why a recv() loop?
// - Raw sockets do not automatically deliver packets to user space unless something reads.
// - The loop keeps the program running and prevents early exit.
// - Actual packet data is discarded here — we only care about triggering the eBPF program.

#include <stdio.h>
#include <unistd.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <net/ethernet.h>
#include <arpa/inet.h>
#include <bpf/libbpf.h>
#include "socket_filter_kern.skel.h"

/* Custom libbpf logging callback.
 * libbpf emits useful warnings/errors during loading/verification.
 * We forward everything up to WARN level to stderr; quieter levels are suppressed.
 */
static int libbpf_print_fn(enum libbpf_print_level level,
                           const char *format, va_list args)
{
    if (level > LIBBPF_WARN)
        return 0;
    return vfprintf(stderr, format, args);
}

/* Increase the locked memory limit.
 * eBPF programs and maps are loaded into kernel memory that counts against
 * RLIMIT_MEMLOCK. Many systems have a low default (e.g., 64 KiB), which is
 * insufficient for non-trivial programs.
 */
static int bump_memlock_rlimit(void)
{
    struct rlimit rlim_new = {
        .rlim_cur = RLIM_INFINITY,
        .rlim_max = RLIM_INFINITY,
    };

    return setrlimit(RLIMIT_MEMLOCK, &rlim_new);
}

int main(int argc, char **argv)
{
    struct socket_filter_kern *skel;
    int err, prog_fd, sock;

    /* Enable libbpf diagnostics */
    libbpf_set_print(libbpf_print_fn);

    /* Raise memory lock limit — often required for successful loading */
    err = bump_memlock_rlimit();
    if (err) {
        fprintf(stderr, "Failed to increase rlimit: %d\n", err);
        return 1;
    }

    /* Open the BPF object — parses ELF and prepares programs/maps */
    skel = socket_filter_kern__open();
    if (!skel) {
        fprintf(stderr, "Failed to open BPF skeleton\n");
        return 1;
    }

    /* Load and verify the program in the kernel.
     * This is where the BPF verifier runs and rejects unsafe programs.
     */
    err = socket_filter_kern__load(skel);
    if (err) {
        fprintf(stderr, "Failed to load BPF program: %d\n", err);
        goto cleanup;
    }

    /* Retrieve the file descriptor of the loaded program */
    prog_fd = bpf_program__fd(skel->progs.socket_filter);
    if (prog_fd < 0) {
        fprintf(stderr, "Failed to get program FD\n");
        goto cleanup;
    }

    /* Create a raw packet socket that receives all Ethernet frames.
     * PF_PACKET + SOCK_RAW gives direct access to link-layer packets.
     * ETH_P_ALL means "all protocols" — we see everything on the interface.
     */
    sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (sock < 0) {
        perror("Failed to create socket");
        goto cleanup;
    }

    /* Attach the eBPF program to the socket.
     * From this point on, every packet received on the socket will execute
     * socket_filter() before reaching user space.
     */
    err = setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &prog_fd, sizeof(prog_fd));
    if (err < 0) {
        perror("Failed to attach BPF program");
        close(sock);
        goto cleanup;
    }

    printf("eBPF socket filter loaded and attached.\n");
    printf("Check /sys/kernel/debug/tracing/trace_pipe for bpf_printk output.\n");
    printf("Generate network traffic (e.g., ping 8.8.8.8) to trigger the program.\n");
    printf("Press Ctrl+C to exit.\n");

    /* Simple receive loop — keeps the socket alive and program running.
     * We discard packet contents; the eBPF program already logged what we need.
     */
    while (1) {
        char buf[1500];  /* Typical Ethernet MTU */
        recv(sock, buf, sizeof(buf), 0);
    }

cleanup:
    /* Skeleton destructor cleans up programs, maps, and links automatically */
    socket_filter_kern__destroy(skel);
    return 1;
}
